package policy

import (
	"net"
	"regexp"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/sirupsen/logrus"
)

type Policy struct {
	ID           int
	State        int
	Description  string
	Priority     int
	NumA         *regexp.Regexp
	NumB         *regexp.Regexp
	NumC         *regexp.Regexp
	SrcIP        []*net.IPNet
	SbcIP        []*net.IPNet
	PeriodStart  int64
	PeriodStop   int64
	Target       string
	MatchCounter int32
}

type PolicyRepository struct {
	mutex    sync.RWMutex
	policies []Policy
	version  string
	lastLoad time.Time
	cache    *PolicyCache
}

type PolicyCacheItem struct {
	Policy   *Policy
	LastUsed time.Time
}

type PolicyCache struct {
	mu    sync.RWMutex
	cache map[string]*PolicyCacheItem
}

func (c *PolicyCache) Set(key string, p *Policy) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.cache[key] = &PolicyCacheItem{
		Policy:   p,
		LastUsed: time.Now(),
	}
}

func (c *PolicyCache) Get(key string) (*Policy, bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()
	item, ok := c.cache[key]
	if !ok {
		return nil, false
	}
	item.LastUsed = time.Now()
	return item.Policy, true
}

func (c *PolicyCache) Cleanup(maxAge time.Duration) {
	c.mu.Lock()
	defer c.mu.Unlock()
	now := time.Now()
	for k, v := range c.cache {
		if now.Sub(v.LastUsed) > maxAge {
			delete(c.cache, k)
		}
	}
}

func makeCacheKey(numA, numB, numC, srcIP, sbcIP string) string {
	return strings.Join([]string{numA, numB, numC, srcIP, sbcIP}, "|")
}

func NewPolicyCache() *PolicyCache {
	return &PolicyCache{
		cache: make(map[string]*PolicyCacheItem),
	}
}

func NewPolicyRepository() *PolicyRepository {
	return &PolicyRepository{
		cache: NewPolicyCache(),
	}
}

func (r *PolicyRepository) SetPolicies(policies []Policy, version string) {
	r.mutex.Lock()
	defer r.mutex.Unlock()

	r.policies = policies
	r.version = version
	r.lastLoad = time.Now()
	r.cache.Cleanup(0)
	logrus.Infof("Policy cache cleared after loading new policies")
}

func (r *PolicyRepository) GetPolicies() []Policy {
	r.mutex.RLock()
	defer r.mutex.RUnlock()
	return r.policies
}

func (r *PolicyRepository) GetVersion() string {
	r.mutex.RLock()
	defer r.mutex.RUnlock()
	return r.version
}

func (r *PolicyRepository) GetLastLoadTime() time.Time {
	r.mutex.RLock()
	defer r.mutex.RUnlock()
	return r.lastLoad
}

func (r *PolicyRepository) FindBestPolicy(numA, numB, numC string, unixTime int64, srcIP, sbcIP, callID string) *Policy {
	start := time.Now()
	key := makeCacheKey(numA, numB, numC, srcIP, sbcIP)

	if cached, ok := r.cache.Get(key); ok {
		atomic.AddInt32(&cached.MatchCounter, 1)
		elapsed := float64(time.Since(start).Microseconds()) / 1000.0
		logrus.Infof("Call-ID: %s — Policy found ID %d (from cache), search time %.3f ms", callID, cached.ID, elapsed)
		return cached
	}

	type result struct {
		policy   *Policy
		index    int
		priority int
	}

	results := make(chan result, len(r.policies))
	var wg sync.WaitGroup

	// Параллельно проверяем политики
	for i, p := range r.policies {
		wg.Add(1)
		go func(idx int, pol Policy) {
			defer wg.Done()

			if unixTime < pol.PeriodStart || unixTime > pol.PeriodStop {
				return
			}
			if !ipInRange(srcIP, pol.SrcIP, callID) || !ipInRange(sbcIP, pol.SbcIP, callID) {
				return
			}
			if !pol.NumA.MatchString(numA) || !pol.NumB.MatchString(numB) || !pol.NumC.MatchString(numC) {
				return
			}

			results <- result{
				policy:   &pol,
				index:    idx,
				priority: pol.Priority,
			}
		}(i, p)
	}

	go func() {
		wg.Wait()
		close(results)
	}()

	var best *Policy
	maxPriority := -1

	for res := range results {
		// берем указатель на оригинальный элемент из среза
		polPtr := &r.policies[res.index]
		if res.priority > maxPriority {
			maxPriority = res.priority
			best = polPtr
		}
	}

	if best != nil {
		atomic.AddInt32(&best.MatchCounter, 1)
		r.cache.Set(key, best)
		elapsed := float64(time.Since(start).Microseconds()) / 1000.0
		logrus.Infof("Call-ID: %s — Best policy ID %d found with priority %d, search time %.3f ms", callID, best.ID, best.Priority, elapsed)
	}

	return best
}

func ipInRange(ipStr string, ranges []*net.IPNet, callID string) bool {
	start := time.Now()

	ip := net.ParseIP(ipStr)
	if ip == nil {
		logrus.Infof("Call-ID: %s — Invalid IP: %s", callID, ipStr)
		return false
	}

	for _, ipNet := range ranges {
		logrus.Debugf("Call-ID: %s — Checking if IP %s is in range %s", callID, ipStr, ipNet.String())

		if ipNet.Contains(ip) {
			logrus.Debugf("Call-ID: %s — IP %s matched range %s", callID, ipStr, ipNet.String())

			elapsed := float64(time.Since(start).Microseconds()) / 1000.0
			logrus.Debugf("Call-ID: %s — ipInRange() search time: %.3f ms", callID, elapsed)

			return true
		}
	}

	elapsed := float64(time.Since(start).Microseconds()) / 1000.0
	logrus.Debugf("Call-ID: %s — IP %s did not match any provided ranges. ipInRange() search time: %.3f ms", callID, ipStr, elapsed)

	return false
}

func (r *PolicyRepository) StartCacheCleanupLoop(interval, maxAge time.Duration) {
	go func() {
		for {
			time.Sleep(interval)
			r.cache.Cleanup(maxAge)
			logrus.Infof("Policy cache cleanup done (maxAge=%s)", maxAge)
		}
	}()
}
